#title "The Page Table"

When RubyFrontier starts to render a page object, it walks the hierarchy gathering directives. When it finishes that process, all the directives are gathered into a hash called the **page table**. This hash is tremendously important; the whole rendering process revolves around it.

In addition to the [directive objects](directiveobjects) and [scalar directives](scalardirectives) already described, RubyFrontier works out and stores some other pieces of information in the page table. It is well to be aware of these, since they can be useful to your scripts, and also because you should not accidentally tromp on them.

> NOTE on the names: These names are pretty terrible, but they are mostly inherited from Frontier, and I have left them unchanged (except for making them lowercase) to ease migration.

* **:adrsiteroottable**. Pathname of the source folder (discovered by looking for `#ftpSite.yaml`).

* **:adrobject**. Pathname of the page object being rendered.

* **:subdirectorypath**: Relative path from the :adrsiteroottable to the folder containing :adrobject.

* **:siterootfolder**. Pathname of the Web site folder into which rendering will be performed. It is derived from the value of the `:folder` key in the hash represented by `#ftpSite.yaml`. You *must* set this value in order for RubyFrontier to know where to save your Web site!

* **:fname**. Name of the Web page file to be created.

* **:f**. Pathname of the Web page file to be created; derived by applying :subdirectorypath to the :siterootfolder and adding :fname.

* **:bodytext**. Temporary holding tank for the contents of the page object, stripped of any internal directives, *before* insertion into the template. In general it should be left untouched, but your pageFilter, if implemented, is *expected* to modify it.

* **:renderedtext**. Ultimate text to be written to `:f`. In general it should be left untouched, but your finalFilter, if implemented, is *expected* to modify it.

* **:autoglossary**. The contents of the `#autoglossary.yaml` file, loaded as a hash. Used when forming links between pages within the site.

### The Structure of the Page Table

It is mostly not your business to know the structure of the page table; but you are not forbidden to know it, either, and knowledge about it can be useful. There are several points in the rendering process (the three filter scripts, macro processing) where the page table is directly available to you, and are free to examine at and (at your own risk) to alter it.

The main thing to know about the page table is that *[scalar directives](scalardirectives)* (prefs, values gathered from within a page object or from a `#prefs.yaml` file), as well as the *values listed on this page* (above), are written into the *top level of the page table*. In other words, if your script has received the page table as a variable called `pt`, then to learn the current `:bgcolor` setting or the `:adrobject` value, you would ask for `pt[:bgcolor]` or `pt[:adrobject]`.

Other folded values, such as pathnames and name-value pairs drawn from inside `#tools`, `#glossary`, and `#images` folders, go into subhashes of their own: `pt["tools"]`, `pt["glossary"]`, `pt["snippets"]`, and `pt["images"]`. (All of those are themselves hashes. The fact that the keys are strings, not symbols, is deliberate.)

Non-folded [directive objects](directiveobjects) encountered as the page table is being built are stored at the top level of the page table as pathnames, keyed by their simple string name (meaning that the initial "#" and the file extension, if any, are stripped). So, for example, the first `#javascripts` folder encountered on the way up the hierarchy has its pathname stored in the page table as `pt["javascripts"]`.
