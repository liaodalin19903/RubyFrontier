#title "Macros and Macro Scoping"

A **macro** is an [ERB](http://ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html) expression in your page object or template. ERB is called to process the page after the page object has been poured into the template (unless you specify that `:processmacros` is false, which would be a very unusual thing to do).

Macros are evaluated under a special set of evaluation rules called **macro scoping**. Also, [outline renderers](outlinerenderers) are run under macro scoping.

###Macro Scoping

In Frontier, when a macro runs, certain abbreviated modes of expression are enabled. This is mostly just a way of making things easier on the programmer writing the macro. For compatibility, RubyFrontier provides a similar mechanism. Linguistically, underneath the hood, the implementation is performed very differently: Frontier uses `with`, whereas RubyFrontier, being Ruby, uses bindings, `method_missing`, introspection, and a lot of other cool stuff. But you don't need to worry about that. You just need to know the rules for these abbreviated modes of expression. So here they are.

* The [page table](pagetable) is in scope, under the name `@adrPageTable`.

* Class methods of `UserLand::Html` are in scope, as methods of the name `html`. So, for example, to call `UserLand::Html::everyPageOfSite`, you can just say `html.everyPageOfSite(adr)` (where `adr` is the required parameter).

* Instance methods of the `UserLand::Html::PageMaker` object that is rendering the page are in scope, also as methods of the name `html`. So, for example, to call `UserLand::Html::PageMaker#getTitleAndPath`, you can just say `html.getTitleAndPath(id)` (where `id` is the required first parameter; this is the PageMaker object that is rendering the current page, so the page table is automatically supplied as the second parameter).

* Scripts in the `#tools` folder are in scope, under their simple names. So, for example, if `#tools` contains a script called `homelink.rb`, you can call it by saying `homelink()`. A tool script should define a top-level method by the same name (e.g. `homelink`). How many parameters it takes and what they mean is entirely up to you. Remember, too, that the tool script itself is running under macro scoping, so it has access to the page table, other tools, and everything else listed here.

* [Standard macros](standardmacros) (instance methods of `UserLand::Html::StandardMacros`) are in scope, under their unqualified method names. So, for example, a macro can say `bodytag()` and the method `UserLand::Html::StandardMacros::bodytag` will be called. Furthermore, the `StandardMacros` module is `include`d in the PageMaker instance that is rendering the page, so a standard macro has access to the page table and can directly call PageMaker instance methods.

* Finally, as a last-ditch effort, keys in the page table hash are themselves in scope, both as symbols and as strings. For example, if you say `title`, and there is no local variable or known method `title`, then (if we call the page table `pt`) `pt[:title]` will be sought, and if that isn't found, `pt["title"]` will be sought.

  However, unlike Frontier, this works only for getting; you cannot set a key in the page table hash in this way. The reason is that the `with` mechanism that permitted this in Frontier was dangerous; it was all too easy to set a value in the page table (or elsewhere in the "database") accidentally. This is no inconvenience, however, because if you want to set a key in the page table hash, you can do so through your access to the page table as `@adrPageTable`.

Note that you can add your own methods to the repertory of things that can be accessed via macro scoping, by defining them in [`user.rb`](user). For example, `user.rb` could define a standard macro as an instance method of UserLand::Html::StandardMacros, and a macro could then call it directly by name. Or, `user.rb` could define a PageMaker method as an instance method of UserLand::Html::PageMaker, and a macro could then call it as a method of `html`.
